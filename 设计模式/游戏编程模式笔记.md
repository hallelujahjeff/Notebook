- [游戏编程模式笔记](#游戏编程模式笔记)
  - [1. 命令模式](#1-命令模式)
    - [撤销和重做](#撤销和重做)
  - [2. 享元模式](#2-享元模式)
  - [3. 观察者模式](#3-观察者模式)
    - [值得注意的问题](#值得注意的问题)
    - [销毁观察者和被观察者](#销毁观察者和被观察者)
  - [4. 原型模式](#4-原型模式)
  - [5. 单例模式](#5-单例模式)
    - [需要注意的问题](#需要注意的问题)
    - [不用单例如何便捷访问对象](#不用单例如何便捷访问对象)
  - [状态机模式](#状态机模式)

# 游戏编程模式笔记

简单做一下各个设计模式的总结，前几章的内容已经有点淡忘了，就精简地回顾一下吧。

## 1. 命令模式

> **将一个请求封装成一个对象，从而允许你使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复。**

将游戏中的行为和操作对象化，抽象称为一个个命令实例。例如，可以抽象一个命令基类：

```
class Command
{
public:
  virtual ~Command(){}
  virtual void execute() = 0;
}
```

然后，将需要游戏中的对象做的操作抽象为一个个命令基类的子类，如跳跃、开火等：

```
class JumpCpmmand : public Command 
{
public:
virtual void execute(GameActor& Actor)
  {
    actor.jump();
}
}
```

将命令执行的操作和命令赋予的对象解耦，可以使一系列的命令不仅能够作用在玩家身上，也可以作用在各种AI身上。我们可以将命令缓存在一个队列里，通过接受玩家的输入、或者AI的输入，不停的产生一系列命令，从而作用在角色身上。

### 撤销和重做

使用命令模式的好处是，我们可以通过向命令里存储状态，来轻松达到撤销和重做的效果。只要将执行过的命令缓存下来即可。

## 2. 享元模式

> **使用共享以高效地支持大量的细粒度对象**

如果需要处理海量游戏对象，应当把这些游戏对象中共有的特性（比如网格、材质等）单独拿出来，作为一个新的类。而游戏对象独有的特性，如位置等，则存放在自己的内存之中。

比如在游戏中需要绘制海量的树木，则在每一棵树木中都存放网格数据显然是不合理的，树只需要存储自己的位置数据即可。而每一棵树对象都拥有一个指针，指向他们共有的树的模型数据。

```cpp
// 共享的树模型数据
class TreeModel
{
  Mesh mesh_;
  Texture bark_;
}

// 树对象只需要存储独有数据即可
class Tree{
  private:
TreeModel* model_;
 vector position_;
}
```

## 3. 观察者模式

> **在对象间定义一种一对多的依赖关系，以便当某对象状态改变时，与它存在依赖关系的所有对象都能收到通知并自动更新。**

这是一个在实际生产中经常会使用到的设计模式，主要解决一些对象调用之间的耦合性问题，让各个不同的模块只需要专注于自己的工作即可。书中给出的例子很清晰了，比如我们并不希望在物理模块中加入一些特殊的检测，来告诉成就系统达成了某某成就。这种情况下只需要定义观察者和被观察者即可。

被观察对象（Subject）通过维护一个观察者列表，来实时向观察者们发送事件：

```cpp
class Subject 
{
public:
  AddObserver(Observer* observer);
  RemoveObserver(Observer* observer);
  
protected:
  Notify(...)
    
private:
  Observer* Observers[_MAX_OBSERVERS]
}
```

### 值得注意的问题

* 观察者模式是同步的，这意味着被观察者发出一个事件之后，需要等待所有观察者都执行完毕后才能返回，这可能会导致潜在的卡顿问题。
* 观察者模式需要维护一个观察者列表，这意味着会有频繁的内存分配。书中提到可以使用链表来解决这个问题。

### 销毁观察者和被观察者

* 当观察者被销毁时，一般都可以知道它观察了哪些对象，从这些对象中注销自己即可。
* 当被观察者销毁时，可以在销毁前通知所有观察者，从而做一些生命周期结束的操作

## 4. 原型模式

> **使用特定实例来创建特定种类的对象，并通过拷贝原型来创建新的对象。**

特点是先实现一个公共基类，它提供一个 `clone() `虚方法，用来构造一个该实例的拷贝。那么我们就可以定义许多继承于此基类的子类，并重写它们的 `clone()` 方法。可能感觉它和拷贝构造函数类似，但也是有区别的。首先拷贝构造函数需要我们显式调用，而使用原型模式的 `clone() `方法是支持多态的，所以通过基类就能够拷贝出不同的子类。并且，使用原型模式可以将实例的状态也一并拷贝。

- Javascript语言就是一个基于原型模式的语言。

## 5. 单例模式

> 确保一个类只有一个实例，并为其提供一个全局访问入口

可以说是最常见的设计模式之一了，核心思想是使用静态方法来提供全局访问，使用私有的构造函数来限制多个实例的创建。总的来说，实现可以如下：

```cpp
class Singleton
{
public:
  static Singleton& Instance()
  {
    if (_instance == NULL)
    {
      _instance = new Singleton();
    }
    return _instance;
  }

private:
  Singleton();

  static Singleton* _instance;

}
```

### 需要注意的问题

1. **全局变量促进了耦合。** 过度依赖单例模式会让模块代码之间串联在一起，在多人协作的情况下你的单例很可能被别人乱用。
2. **对并发不友好。** 多线程都可以访问这个单例，会引发很多内存危险的操作。


### 不用单例如何便捷访问对象

使用单例的目的是为了便捷地访问对象实例，那么除了单例，还有什么办法可以访问一个对象呢？

- **作为函数入参传递。** 许多渲染物体的函数都会传入一个context作为上下文。
- **从基类获取** 。例如Unity中的游戏对象都继承于基类GameObject，UE中的对象都可以通过 `GetWorld() `拿到一个与其相关的世界对象。
- **使用服务定位器来访问。** 参考服务定位器模式（第16章）。

## 状态机模式
